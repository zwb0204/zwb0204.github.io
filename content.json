{"meta":{"title":"Bluetooth Space IDH","subtitle":"Bluetooth solution provider","description":"Bluetooth Evangelist","author":"Harry Zhang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-06-26T04:56:32.000Z","updated":"2020-06-26T05:23:13.266Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-06-26T01:25:53.000Z","updated":"2020-06-26T05:23:01.815Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-06-26T01:25:29.000Z","updated":"2020-06-26T05:22:47.712Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"QCC MDE 开发初窥(二)","slug":"QCC MDE 开发初窥(二)","date":"2020-07-04T14:28:22.877Z","updated":"2020-07-05T10:18:14.203Z","comments":true,"path":"2020/07/04/QCC MDE 开发初窥(二)/","link":"","permalink":"http://yoursite.com/2020/07/04/QCC%20MDE%20%E5%BC%80%E5%8F%91%E5%88%9D%E7%AA%A5(%E4%BA%8C)/","excerpt":"[TOC] 前言搭建好开发环境，输出log 信息之后，在阅读代码过程中发现，新的软件架构在task ,message方面，新增了一些应用，例如message_boker, Task list之类的。本文就针对新增的message , task list的原理做一个阐述","text":"[TOC] 前言搭建好开发环境，输出log 信息之后，在阅读代码过程中发现，新的软件架构在task ,message方面，新增了一些应用，例如message_boker, Task list之类的。本文就针对新增的message , task list的原理做一个阐述 MESSAGE_BASE &amp; MESSAGE_GROUP在代码中出现了诸如LOGIC_INPUT_MESSAGE_BASE , UI_TELEPHONY_MESSAGE_GROUP 之类的，搜寻代码，无法找到它们这些消息ID的定义，其实这些定义都在domain_message.h 中已经定义，详情如下： 首先了解xx_MESSAGE_GROUP 和xx_MESSAGE_BASE 之间的关系 1xx_MESSAGE_GROUP = xx_MESSAGE_BASE &lt;&lt; 8 所有的MESSAGE_GROUP的定义 12345678enum message_groups&#123; FOREACH_DOMAINS_MESSAGE_GROUP(EXPAND_AS_MESSAGE_GROUP_ENUM) FOREACH_SERVICES_MESSAGE_GROUP(EXPAND_AS_MESSAGE_GROUP_ENUM) FOREACH_TOPOLOGY_MESSAGE_GROUP(EXPAND_AS_MESSAGE_GROUP_ENUM) FOREACH_APPS_MESSAGE_GROUP(EXPAND_AS_MESSAGE_GROUP_ENUM) FOREACH_UI_INPUTS_MESSAGE_GROUP(EXPAND_AS_MESSAGE_GROUP_ENUM)&#125;; 它等价于如下代码,具体的细节查看domain_message.h ： 1234567891011121314151617181920212223enum message_groups&#123; INTERNAL_MESSAGE_GROUP, AV_MESSAGE_GROUP, /* See #av_status_messages */ \\ ................................................................ LEAKTHROUGH_MESSAGE_GROUP, /* See leakthrough_msg_t */\\ QCOM_CON_MANAGER_MESSAGE_GROUP, HANDSET_SERVICE_MESSAGE_GROUP, ............................ AUDIO_CURATION_SERVICE_MESSAGE_GROUP, TWS_TOPOLOGY_SERVICE_MESSAGE_GROUP, /* See #tws_topology_message_t */ \\ TWS_TOPOLOGY_CLIENT_NOTIFIER_SERVICE_MESSAGE_GROUP, HEADSET_TOPOLOGY_SERVICE_MESSAGE_GROUP, SYSTEM_SERVICE_MESSAGE_GROUP, CONN_RULES_SERVICE_MESSAGE_GROUP, EARBUD_ROLE_SERVICE_MESSAGE_GROUP, UI_INPUTS_TELEPHONY_MESSAGE_GROUP, ................................. UI_INPUTS_BOUNDS_CHECK_MESSAGE_GROUP&#125; MESSAGE_GROUP 的值确定了，那么每个group的MESSAGE_BASE值也随之确认 12345678typedef enum&#123; FOREACH_DOMAINS_MESSAGE_GROUP(EXPAND_AS_MESSAGE_BASE_ENUM) FOREACH_SERVICES_MESSAGE_GROUP(EXPAND_AS_MESSAGE_BASE_ENUM) FOREACH_TOPOLOGY_MESSAGE_GROUP(EXPAND_AS_MESSAGE_BASE_ENUM) FOREACH_APPS_MESSAGE_GROUP(EXPAND_AS_MESSAGE_BASE_ENUM) FOREACH_UI_INPUTS_MESSAGE_GROUP(EXPAND_AS_MESSAGE_BASE_ENUM)&#125; message_base_t; 它等价以下代码： 1234567891011121314151617181920212223enum message_groups&#123; INTERNAL_MESSAGE_GROUP &lt;&lt; 8, AV_MESSAGE_GROUP &lt;&lt; 8, /* See #av_status_messages */ \\ ................................................................ LEAKTHROUGH_MESSAGE_GROUP &lt;&lt; 8, /* See leakthrough_msg_t */\\ QCOM_CON_MANAGER_MESSAGE_GROUP &lt;&lt; 8, HANDSET_SERVICE_MESSAGE_GROUP &lt;&lt; 8, ............................ AUDIO_CURATION_SERVICE_MESSAGE_GROUP &lt;&lt; 8, TWS_TOPOLOGY_SERVICE_MESSAGE_GROUP &lt;&lt; 8, /* See #tws_topology_message_t */ \\ TWS_TOPOLOGY_CLIENT_NOTIFIER_SERVICE_MESSAGE_GROUP &lt;&lt; 8, HEADSET_TOPOLOGY_SERVICE_MESSAGE_GROUP &lt;&lt; 8, SYSTEM_SERVICE_MESSAGE_GROUP &lt;&lt; 8, CONN_RULES_SERVICE_MESSAGE_GROUP &lt;&lt; 8, EARBUD_ROLE_SERVICE_MESSAGE_GROUP &lt;&lt; 8, UI_INPUTS_TELEPHONY_MESSAGE_GROUP &lt;&lt; 8, ................................. UI_INPUTS_BOUNDS_CHECK_MESSAGE_GROUP &lt;&lt; 8&#125; MESSAGE_BROKER有关message_broker官方只有如下说明： ​ The Message Broker allows client modules to register interest​ in System Messages by Message Group. The Message Broker registers​ with the message group owner on behalf of the client module. The​ message group owner subsequently messages the client module directly.​ The message group owner’s messge group ID and registration function​ is provides to message broker in MessageBroker_init(). 意思是：message broker允许将感兴趣的message_group注册到系统消息中。 应该代码中只应用到两个API: MessageBroker_Init() 代码中该代码中的涉及的参数message_broker_group_registrations_end[]和message_broker_group_registrations_begain[]具体定义都不可见。所以 MessageGroupRegister 和MessageGroupUnregister 两个函数的定义也未知。 void MessageBroker_RegisterInterestInMsgGroups(Task task, const message_group_t* msg_groups, unsigned num_groups) num_groups是指在*msg_groups为第一个message_group,在此基础上的几个message_group. 此函数最后要调用registration-&gt;MessageGroupRegister(task, group) ，但由于MessageGroupRegister的具体定义未知，所以也无从查询它究竟做了什么. 疑问? message_broker的具体怎么应用，目前尚未知道，在后续的代码中希望可以找到答案。 Tasklist applicationtask list 中应用到的结构体如下图所示： ![](QCC MDE 开发初窥(二)/task_list_struct.png) 创建task list 动态的task list : TaskList_Create() 静态的task list : TaskList_Initralise()， 它设置 目前代码中，两者创建的容量都是1，唯一区别就是no_destroy的赋值不一样，动态赋值：false, 静态赋值TRUE TaskList_AddTask(), 一般在register一个task的时候就需要该操作 使用过程中，就可以利用task list 来发送消息：Tasklist_MessageSendId() 动态创建tasklist后，unresgister 一个task的时候： TaskList_RemoveTask() 通过TaskList_Size()判断 task 是否为零，如果等于零，则TaskList_Destroy()","categories":[{"name":"QCC","slug":"QCC","permalink":"http://yoursite.com/categories/QCC/"}],"tags":[{"name":"technology","slug":"technology","permalink":"http://yoursite.com/tags/technology/"}]},{"title":"Markdwon 常用语法","slug":"Markdwon 常用语法","date":"2020-06-27T01:47:24.558Z","updated":"2020-07-05T10:13:53.013Z","comments":true,"path":"2020/06/27/Markdwon 常用语法/","link":"","permalink":"http://yoursite.com/2020/06/27/Markdwon%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/","excerpt":"[TOC] 我写作使用的工具是Typora，免费，且方便快捷的集合了一些语法，以下的操作都是基于Typora 工具的，写一篇文章足够。","text":"[TOC] 我写作使用的工具是Typora，免费，且方便快捷的集合了一些语法，以下的操作都是基于Typora 工具的，写一篇文章足够。 分级标题，一共六级 1234# 一级标题## 二级标题....###### 六级标题 列表 1- 文本 代码段 1​&#96;&#96;&#96;c &#x2F;&#x2F; 输入此内容，自动变为代码块 引用 1&gt; 文本 插入链接 1[文本]（www.example.com） 待办事项 1- [x] 文本 &#x2F;&#x2F; 括号内需空格或者x 字体 12345&#x3D;&#x3D;文本&#x3D;&#x3D; &#x2F;&#x2F; 高亮*文本* &#x2F;&#x2F; 斜体**文本** &#x2F;&#x2F; 加粗***文本*** &#x2F;&#x2F; 斜体加粗&#96;文本&#96; &#x2F;&#x2F; 加背景 插入图片 在_post文件下同时新建一个与文档名字一样的文件夹，将图片放入其中，在文档中用以下方式插入图片 待续。。。","categories":[{"name":"tool","slug":"tool","permalink":"http://yoursite.com/categories/tool/"}],"tags":[{"name":"life","slug":"life","permalink":"http://yoursite.com/tags/life/"}]},{"title":"Hexo user guide","slug":"Hexo user guide","date":"2020-06-26T15:12:14.000Z","updated":"2020-06-26T16:19:34.099Z","comments":true,"path":"2020/06/26/Hexo user guide/","link":"","permalink":"http://yoursite.com/2020/06/26/Hexo%20user%20guide/","excerpt":"[TOC] Build Private Blog搭建过程参考文章：https://zhuanlan.zhihu.com/p/32957389 个人域名在阿里云申请的","text":"[TOC] Build Private Blog搭建过程参考文章：https://zhuanlan.zhihu.com/p/32957389 个人域名在阿里云申请的 USER Guide 更新个人信息，在根目录的_config.yml 中更新博客名字，作者，git 仓库地址等等。 将写好的文章直接放在目录：source/_posts下面 使用命令： hexo g // 如果有变动，执行命令生成 hexo s // 本地预览命令 hexo server -p 5000 // 如果4000端口被占用，则使用此命令更换端口 hexo d // commit 本地改动到github 修改完主题完配置后，最好先执行 hexo clean 网页优化 首页不要显示全文 在文档中截取需要预览的部分, 文章之后输入： 1&lt;!-- more --&gt; 例如代码块复制，增加分页等优化功能，7.8.0版本都已经集合，只需在主题配置中将该部分的功能设定改为enable：true 更换电脑如果更换电脑后，怎么重新配置呢？待续… 网站浏览个人博客地址：蓝牙空间","categories":[{"name":"tool","slug":"tool","permalink":"http://yoursite.com/categories/tool/"}],"tags":[{"name":"life","slug":"life","permalink":"http://yoursite.com/tags/life/"}]},{"title":"QCC MDE 开发初窥（一）","slug":"QCC MDE 开发初窥(一)","date":"2020-06-24T02:21:10.236Z","updated":"2020-06-26T05:16:15.555Z","comments":true,"path":"2020/06/24/QCC MDE 开发初窥(一)/","link":"","permalink":"http://yoursite.com/2020/06/24/QCC%20MDE%20%E5%BC%80%E5%8F%91%E5%88%9D%E7%AA%A5(%E4%B8%80)/","excerpt":"QCC MDE 开发初窥(一)[TOC] 前言QCC收购CSR之后，将SDK的架构进行了大改，从ADK6.x 版本开始，使用的IDE是MDE+Toolkit ,对于基于CSR 时代的软件开发者来说，需要重新学习，我后续将QCC平台的开发心得一一阐述，节约开发者的学习成本。","text":"QCC MDE 开发初窥(一)[TOC] 前言QCC收购CSR之后，将SDK的架构进行了大改，从ADK6.x 版本开始，使用的IDE是MDE+Toolkit ,对于基于CSR 时代的软件开发者来说，需要重新学习，我后续将QCC平台的开发心得一一阐述，节约开发者的学习成本。 开发环境安装安装包包含以下三部分,按照安装步骤安装即可： 开发包目前有两种：基于QCC512x_QCC302x芯片平台的使用ADK_QCC512x_QCC302x_WIN_6.4.2.26; 基于QCC514x_QCC304x芯片平台的使用ADK_Tookkit_1.0.1.19 + qcc514x-qcc304x-src-1-0_qtil_standard_oem_earbud.git. 开发IDE都使用MDE_WIN_2.4.1.4 Bluesuit3.3.2 注意 ：安装成功后，python的安装程序已经包含在ADK_QCC512X_QCC302X_WIN_6.4.2.26\\tools\\python27中，如果是Toolkit ,则包含在： ADK_Toolkit_1.0.1.19_x64\\tools\\python27\\，无需下载python安装包进行安装。 开发环境配置和TRBI200连线 安装完毕之后，需要在python中配置默认字体encoding为gbk, 以ADK_Toolkit_1.0.1.19为例，修改步骤如下： 在..\\ADK_Toolkit_1.0.1.19_x64\\tools\\python27\\Lib\\site-packages\\中新建文件：sitecustomize.py, 输入代码： 1234inport sys reload(sys)sys.setdefaultencoding(‘gbk’) 解决问题：如果不修改程gbk， 在log输出的时候会遇到无法解析的问题。 在工程配置文件中，需要remove 5个宏定义： ![image-20200623214923992](C:\\Users\\Harry zhang\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200623214923992.png) 解决问题：如果电路中没有温度检测电路的话，运行默认程序会造成通信dead, 程序无法正常运行。 TRBI200 接口连接注意事项 TRBI200的16PIN接口分布如下图右下角所示，TRBI200中只需接四个接口中的一个接口即可，另外加TX_CLK, VCC(1.8V or 3.3V), GND 一共5pin ，速度可以达到10MHz, 判断传输通道是否OK，可以观察以下几个LEDS是否常亮: STATUS, TRB SE, TRB SE VCC。 ![image-20200623220346476](C:\\Users\\Harry zhang\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200623220346476.png) 编译，烧录，输出调试信息 编译，烧录，输出调试信息全部可以通过MDE完成，步骤见下图所示，烧录的的时候注意，一定要将SYS_CTRL脚拉高hold住。 ![image-20200623222238549](C:\\Users\\Harry zhang\\AppData\\Roaming\\Typora\\typora-user-images\\image-20200623222238549.png) 更改log leve ,默认的log level 是2， 即DEBUG_LOG_LEVEL_INFO。 使用的调试输出代码格式： 1DEBUG_LOG_INFO(\"handleMessageAppInitStart\"); 如要改成其他的log level , 则在项目属性中定义宏：SET_LOG_LEVEL=x , x对应以下枚举值： 12345678typedef enum &#123; DEBUG_LOG_LEVEL_ERROR, DEBUG_LOG_LEVEL_WARN, DEBUG_LOG_LEVEL_INFO, DEBUG_LOG_LEVEL_DEBUG, DEBUG_LOG_LEVEL_VERBOSE, DEBUG_LOG_LEVEL_V_VERBOSE,&#125; debug_log_level_t; 对应的调试代码为： 123456DEBUG_LOG_ERROR(...) DEBUG_LOG_WARN(...) DEBUG_LOG_INFO(...) DEBUG_LOG_DEBUG(...) DEBUG_LOG_VERBOSE(...) DEBUG_LOG_V_VERBOSE(...) 至此，你已经可以拿到板子正常运行程序，并且进行代码调试了。","categories":[{"name":"QCC","slug":"QCC","permalink":"http://yoursite.com/categories/QCC/"}],"tags":[{"name":"technology","slug":"technology","permalink":"http://yoursite.com/tags/technology/"}]}],"categories":[{"name":"QCC","slug":"QCC","permalink":"http://yoursite.com/categories/QCC/"},{"name":"tool","slug":"tool","permalink":"http://yoursite.com/categories/tool/"}],"tags":[{"name":"technology","slug":"technology","permalink":"http://yoursite.com/tags/technology/"},{"name":"life","slug":"life","permalink":"http://yoursite.com/tags/life/"}]}